const{isArray:e}=Array;class t extends String{}const{defineProperty:n}=Object,r=(n,r)=>(o,...s)=>new Promise(((c,l)=>{if(o.some((e=>e.includes("?")))){const e=new Error("SQLITE_ERROR: SQL injection hazard");e.code="SQLITE_ERROR",l(e)}else{const[a,...i]=((n,...r)=>{const o=[n[0]],s=[o];for(let c=0;c<r.length;c++)r[c]instanceof t?o[o.length-1]+=r[c]+n[c+1]:(e(r[c])?(o.push(...r[c].slice(1).map((e=>","))),s.push(...r[c])):s.push(r[c]),o.push(n[c+1]));return s})(o,...s);n[r](a.join("?"),i,((e,t)=>{e?l(e):c(t)}))}}));function o(e){const o=r(e,"run");return{transaction(){let e=o(["BEGIN TRANSACTION"]);return n(((...t)=>{e=e.then((()=>o(...t)))}),"commit",{value:()=>e=e.then((()=>o(["COMMIT"])))})},all:r(e,"all"),get:r(e,"get"),raw:(e,...n)=>{return r=function(e){for(var t=e[0],n=1,r=arguments.length;n<r;n++)t+=arguments[n]+e[n];return t}(e,...n),new t(r);var r},close:()=>e.close(),query:o}}const{assign:s}=Object,c="function"==typeof importScripts,l=e=>new Promise(((t,n)=>{const r=()=>{const e=self.module.exports;delete self.exports,self.module=void 0,t(e)};if(self.exports={},self.module={exports:exports},c)importScripts(e),r();else{const{head:t}=document;s(t.appendChild(document.createElement("script")),{onload(){t.removeChild(this),r()},onerror:n,src:e})}})),a="sqlite",i="buffer",u=(e,t=1)=>new Promise(((n,r)=>{s(indexedDB.open(e,t),{onupgradeneeded({target:{result:e,transaction:t}}){e.objectStoreNames.contains(a)||e.createObjectStore(a).createIndex(i,i,{unique:!0}),s(t,{oncomplete(){n(e)}})},onsuccess({target:{result:e}}){n(e)},onerror:r})}));function p({columns:e,values:t}){for(let{length:n}=t,r=0;r<n;r++){const n=t[r],o={};for(let{length:t}=e,r=0;r<t;r++)o[e[r]]=n[r];this.push(o)}}exports.init=(e={})=>new Promise(((t,n)=>{const r=e.dist||".";l(r+"/sql-wasm.js").then((({default:c})=>{Promise.all([u(e.name||"sqlite-worker"),c({locateFile:e=>r+"/"+e})]).then((([r,{Database:c}])=>{const l=e=>r.transaction([a],e).objectStore(a);s(l("readonly").get(i),{onsuccess(){let n=Promise.resolve();const{result:r}=this,a=new c(r||e.database||new Uint8Array(0)),u=()=>n=n.then((()=>new Promise(((t,n)=>{const r=a.export();s(l("readwrite").put(r,i).transaction,{oncomplete(){t(),e.update&&e.update(r)},onabort:n,onerror:n})}))));r||u();const{all:d,get:h,query:m,raw:f,transaction:g}=o({all(e,t,n){try{const r=a.exec(e,t),o=[];r.forEach(p,o),n(null,o)}catch(e){n(e)}},get(e,t,n){try{const r=a.exec(e+" LIMIT 1",t),o=[];r.forEach(p,o),n(null,o.shift()||null)}catch(e){n(e)}},run(e,t,n){try{n(null,a.run(e,t))}catch(e){n(e)}}});let w=0;t({all:d,get:h,raw:f,transaction:g,create_function:(e,t)=>a.create_function(e,t),close:()=>(clearTimeout(w),u().then((()=>a.close()))),query(t){return/\b(?:INSERT|DELETE|UPDATE)\b/i.test(t[0])&&(clearTimeout(w),w=setTimeout(u,e.timeout||250)),m.apply(this,arguments)}})},onerror:n})}),n)}))}));