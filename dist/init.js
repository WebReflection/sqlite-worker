const{isArray:e}=Array;class t extends String{}const{defineProperty:r}=Object,n=(r,n)=>(o,...s)=>new Promise(((l,c)=>{if(o.some((e=>e.includes("?")))){const e=new Error("SQLITE_ERROR: SQL injection hazard");e.code="SQLITE_ERROR",c(e)}else{const[a,...i]=((r,...n)=>{const o=[r[0]],s=[o];for(let l=0;l<n.length;l++)n[l]instanceof t?o[o.length-1]+=n[l]+r[l+1]:(e(n[l])?(o.push(...n[l].slice(1).map((e=>","))),s.push(...n[l])):s.push(n[l]),o.push(r[l+1]));return s})(o,...s);r[n](a.join("?"),i,((e,t)=>{e?c(e):l(t)}))}}));function o(e){const o=n(e,"run");return{transaction(){let e=o(["BEGIN TRANSACTION"]);return r(((...t)=>{e=e.then((()=>o(...t)))}),"commit",{value:()=>e=e.then((()=>o(["COMMIT"])))})},all:n(e,"all"),get:n(e,"get"),raw:(e,...r)=>{return n=function(e){for(var t=e[0],r=1,n=arguments.length;r<n;r++)t+=arguments[r]+e[r];return t}(e,...r),new t(n);var n},close:()=>e.close(),query:o}}const{assign:s}=Object,l="function"==typeof importScripts,c=e=>new Promise(((t,r)=>{const n=()=>{const e=self.module.exports;delete self.exports,self.module=void 0,t(e)};if(self.exports={},self.module={exports:exports},l)importScripts(e),n();else{const{head:t}=document;s(t.appendChild(document.createElement("script")),{onload(){t.removeChild(this),n()},onerror:r,src:e})}})),a=(e,t=1)=>new Promise(((r,n)=>{s(indexedDB.open(e,t),{onupgradeneeded({target:{result:e,transaction:t}}){e.objectStoreNames.contains("sqlite")||e.createObjectStore("sqlite").createIndex("buffer","buffer",{unique:!0}),s(t,{oncomplete(){r(e)}})},onsuccess({target:{result:e}}){r(e)},onerror:n})}));function i({columns:e,values:t}){for(let{length:r}=t,n=0;n<r;n++){const r=t[n],o={};for(let{length:t}=e,n=0;n<t;n++)o[e[n]]=r[n];this.push(o)}}exports.init=(e={})=>new Promise(((t,r)=>{const n=e.dist||".";c(n+"/sql-wasm.js").then((({default:l})=>{Promise.all([a(e.name||"sqlite-worker"),l({locateFile:e=>n+"/"+e})]).then((([n,{Database:l}])=>{const c=e=>n.transaction(["sqlite"],e).objectStore("sqlite");s(c("readonly").get("buffer"),{onsuccess(){let r=Promise.resolve();const{result:n}=this,a=new l(n||e.database||new Uint8Array(0)),u=()=>{r=r.then((()=>new Promise(((t,r)=>{const n=a.export();s(c("readwrite").put(n,"buffer").transaction,{oncomplete(){t(),e.update&&e.update(n)},onabort:r,onerror:r})}))))};n||u();const{all:p,get:d,query:f,raw:h,transaction:m}=o({all(e,t,r){try{const n=a.exec(e,t),o=[];n.forEach(i,o),r(null,o)}catch(e){r(e)}},get(e,t,r){try{const n=a.exec(e+" LIMIT 1",t),o=[];n.forEach(i,o),r(null,o.shift()||null)}catch(e){r(e)}},run(e,t,r){try{r(null,a.run(e,t))}catch(e){r(e)}}});let g=0;t({all:p,get:d,raw:h,transaction:m,query(t){return/\b(?:INSERT|DELETE|UPDATE)\b/i.test(t[0])&&(clearTimeout(g),g=setTimeout(u,e.timeout||250)),f.apply(this,arguments)}})},onerror:r})}),r)}))}));